@uniform shadow_tr "shadow tr"
@uniform shadow_dist_bias "shadow dist bias"
@sampler shadow_map "shadow"
//@sampler shadow_poisson "shadow poisson"
//@predefined model_scale "nya model scale"

@all
//varying vec3 vpos;
varying vec4 shadow_tc;

@vertex
uniform mat4 shadow_tr;
//uniform vec4 model_scale;

void shadow(vec4 wpos)
{
    shadow_tc = shadow_tr * wpos;
    shadow_tc.xyz = 0.5 * (shadow_tc.xyz + shadow_tc.w);
    //vpos = (gl_Vertex * model_scale).xyz;
}

@fragment
uniform sampler2D shadow_map;
uniform vec4 shadow_dist_bias;

//uniform sampler2D shadow_poisson;
//
//float random(vec3 seed, int i)
//{
//    vec4 seed4 = vec4(seed,i);
//    float dot_product = dot(seed4, vec4(12.9898,78.233,45.164,94.673));
//    return fract(sin(dot_product) * 43758.5453);
//}

float shadow(float ndl01)
{
    vec2 shad_xy = shadow_tc.xy / shadow_tc.w;
    float shad_z = shadow_tc.z / shadow_tc.w - shadow_dist_bias.a;
    float shadow = 1.0;
//    for (int i = 0; i < 6; ++i)
//    {
//        float index = random(floor(vpos*1000.0), i);
//        vec2 dtc = texture2D(shadow_poisson, vec2(index, 0.5)).xy;
//        shadow -= 0.1667 * step(texture2D(shadow_map, shad_xy + dtc).r - shad_z, 0.0);
//    }

    shadow -= step(texture2D(shadow_map, shad_xy).r - shad_z, 0.0);

    vec2 b = step(vec2(0.0), shad_xy) * step(shad_xy, vec2(1.0));
    return max(shadow, 1.0 - b.x * b.y);
}
