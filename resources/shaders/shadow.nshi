@uniform shadow_tr "shadow tr"
@uniform shadow_cascades "shadow cascades"
@sampler shadow_map "shadow"
//@sampler shadow_poisson "shadow poisson"
@predefined model_scale "nya model scale"

@all
varying vec4 vpos;
varying vec4 shadow_tc[4];

@vertex
uniform mat4 shadow_tr[4];
uniform vec4 model_scale;

void shadow(vec4 wpos)
{
    for (int i = 0; i < 4; ++i)
    {
        shadow_tc[i] = shadow_tr[i] * wpos;
        shadow_tc[i].xyz = 0.5 * (shadow_tc[i].xyz + shadow_tc[i].w);
    }
    vpos = vec4((gl_Vertex * model_scale).xyz, wpos.z);
}

@fragment
uniform sampler2D shadow_map;
uniform vec4 shadow_cascades;

//uniform sampler2D shadow_poisson;
//
//float random(vec3 seed, int i)
//{
//    vec4 seed4 = vec4(seed,i);
//    float dot_product = dot(seed4, vec4(12.9898,78.233,45.164,94.673));
//    return fract(sin(dot_product) * 43758.5453);
//}

float shadow(float ndl01)
{
    if (ndl01 < 0.001)
        return 0.0;

    vec3 d3 = step(shadow_cascades.xyz, vpos.www);
    float d = d3.x + d3.y + d3.z;
    vec2 offset = vec2(0.5 * step(0.5, float(mod(d, 2.0))), 0.5 * step(1.5, d));
    int i = int(d);

    vec2 shad_xy = shadow_tc[i].xy / shadow_tc[i].w * 0.5 + offset;
    float shad_z = shadow_tc[i].z / shadow_tc[i].w;
    float shadow = 1.0;
//    for (int i = 0; i < 6; ++i)
//    {
//        float index = random(floor(vpos.xyz*1000.0), i);
//        vec2 dtc = texture2D(shadow_poisson, vec2(index, 0.5)).xy;
//        shadow -= 0.1667 * step(texture2D(shadow_map, shad_xy + dtc).r - shad_z, 0.0);
//    }

    shadow -= step(texture2D(shadow_map, shad_xy).r - shad_z, 0.0);
    return shadow;
}
